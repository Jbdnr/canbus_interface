#!/usr/bin/env python
from __future__ import print_function
import rospy
import struct
import numpy
from std_msgs.msg import Float32
from std_msgs.msg import Float64
from ackermann_msgs.msg import AckermannDriveStamped
import can_interface as ci

# IDENTYFIATORY PUBLIKOWANYCH RAMEK
SPEED_PUB_ID = 0x1A  # TBD
STEERING_PUB_ID = 0x1B  # TBD

# IDENTYFIATORY SUBSKRYBOWANYCH RAMEK
SPEED_FEEDBACK_ID = 0x31D # 797
STEERING_FEEDBACK_ID = 0x32D # 813
DISTANCE_FEEDBACK_ID = 0x33D # 829

ackermann_angle = 0.0
ackermann_speed = 0.0
speed = 0.0
distance = 0.0
steering_angle = 0.0

def ackermann_callback(msg):
    global ackermann_angle
    ackermann_angle = msg.drive.steering_angle
    global ackermann_speed
    ackermann_speed = msg.drive.speed

def main():
    rospy.init_node('can_node', anonymous=True)
    rospy.Subscriber('drive', AckermannDriveStamped, ackermann_callback)
    speed_pub = rospy.Publisher('speed', Float64, queue_size=10)
    distance_pub = rospy.Publisher('distance', Float64, queue_size=10)
    angle_pub = rospy.Publisher('steering_angle', Float64, queue_size=10)

    # converter = Converter(angle_lookup_table, speed_lookup_table, 0, 0)

    can_sub = ci.CanSubscriber(SPEED_FEEDBACK_ID, STEERING_FEEDBACK_ID, DISTANCE_FEEDBACK_ID)
    can_sub.can_subscriber()

    rate = rospy.Rate(10)  # 10hz
    while not rospy.is_shutdown():
        print(can_sub.distance_frame_id)
        speed_pub.publish(speed)
        distance_pub.publish(distance)
        angle_pub.publish(steering_angle)
        can_pub_speed = ci.CanPublisher(SPEED_PUB_ID, ackermann_speed)
        can_pub_speed.can_publisher()
        can_pub_angle = ci.CanPublisher(STEERING_PUB_ID, ackermann_angle)
        can_pub_angle.can_publisher()
        rate.sleep()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
    ci.CanSubscriber.stop_event.set()
